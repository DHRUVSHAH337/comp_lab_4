#ifndef __TRANSLATOR_H
#define __TRANSLATOR_H

#include <bits/stdc++.h>
using namespace std;

/*
    An enum for all data types
*/
typedef enum {
    data_type_void,
    data_type_bool,
    data_type_char,
    data_type_integer,
    data_type_float,
    data_type_array,
    data_type_pointer,
    data_type_function
} data_type;

/*
    An enum for all opcodes
*/
typedef enum  {
    ADD, SUB, MULT, DIV, MOD, SL, SR, 
    BW_AND, BW_OR, BW_XOR, 
    BW_U_NOT ,U_PLUS, U_MINUS, REFERENCE, DEREFERENCE, U_NEG, 
    GOTO_EQ, GOTO_NEQ, GOTO_GT, GOTO_GTE, GOTO_LT, GOTO_LTE, IF_GOTO, IF_FALSE_GOTO, 
    CtoI, ItoC, FtoI, ItoF, FtoC ,CtoF, 
    ASSIGN, GOTO, RETURN, PARAM, CALL, ARR_IDX_ARG, ARR_IDX_RES, FUNC_BEG, FUNC_END, L_DEREF
} opcode;

class quad;
class quad_array;
/*
    External variables and methods generated by bison
*/
extern char* yytext;
extern int yyparse();

class symbol_type {     // class for denoting the type of the symbol
public:
    int pointers;       // for pointers
    data_type type;     // denotes the type stored in the enum
    data_type nextType; // it stores the information of the type of elements stored in it
    vector<int> dimension_vector;   // stores the dimensions
};

class symbol_value { // to store the values of the symbol
public:
    int i;              // integers
    char c;             // characters
    float f;            // float values
    void* p;            // pointers

    /*
    for setting the initial values
    */
    void setInitVal(int val); 
    void setInitVal(char val);
    void setInitVal(float val);
};

class symbol;
class symbol_table;

class symbol {          // symbol class to store the element of the symbol table
public:
    string name;        // name
    symbol_type type;   // type of the symbol
    symbol_value* initVal;  // initial value
    int size;           // it's size
    int offset;         // relative address or offset
    symbol_table* nestedTable;  // pointer to a nested table if any

    symbol();           // constructor
};


class symbol_table {        // to store the whole symbol table
public:
    map<string, symbol*> table; // map of symbols stored using their names
    vector<symbol*> symbols;    // vector of symbols
    int offset;                 // offset
    static int tempCount;       // count of temporary variables

    symbol_table();             // constructor
    symbol* lookup(string name, data_type t = data_type_integer, int pc = 0);       // lookup for the variables of same names and to store them for the new ones
    symbol* searchGlobal(string name);                  // to serach in the symbol table
    string gentemp(data_type t = data_type_integer);    // to generate temporary variables

    void print(string tableName);           // printing the whole symbol table
};

class quad {        // stores the whole three address code
public:
    opcode op;      // type of operation
    string arg1;    // argument 1
    string arg2;    // argument 2
    string result;  // result

    quad(string, string, string, opcode);//constructor

    string print(); // printing the whole quad
};

class quad_array {  // to store all the TAC
public:
    vector<quad> quads;     // vector of quads

    void print();       // printing the list
};



class expression {      // storing an expression
public:
    int instr;          // instruction number of the expression
    data_type type;     // it's type
    string loc;         // entry location in symbol table
    list<int> truelist; // truelist
    list<int> falselist;// falselist
    list<int> nextlist; // nextlist
    /*
    to be used by arrays and pointers
    */
    int fold;           
    string* folder;

    expression();// constructor
};

class param {       // for parameters 
public:
    string name;    // name of the parameters
    symbol_type type;   // its type
};

class declaration {     // to store the declarations
public:
    string name;        // name of the declaration
    int pointers;       // count of pointers
    data_type type;     // it's type
    data_type nextType; // used for arrays and pointers
    vector<int> li;     // list of the instruction
    expression* initVal;    // it's initial value
    int pc;             // used for arrays and pointers
};

/*
    Spits a 3 Address Code of the form: result = arg1 op arg2
– op usually is a binary operator. If arg2 is
missing, op is unary. If op also is missing, this
is a copy instruction.
*/
void emit(string result, string arg1, string arg2, opcode op);
void emit(string result, int constant, opcode op);
void emit(string result, char constant, opcode op);
void emit(string result, float constant, opcode op);

/*
    – Creates a new list containing only i, an index into the array of quad’s.
    – Returns a pointer to the newly created list
*/
list<int> makelist(int i);
/*
    – Concatenates the lists pointed to by list1 and list2 .
    – Returns a pointer to the concatenated list
*/
list<int> merge(list<int> list1, list<int> list2);

/*
    – Inserts i as the target label for each of the quads on the list pointed to by p.
*/
void backpatch(list<int> l, int address);

void convertToType(expression* arg, expression* res, data_type toType); // conversion from one type to another

void convertToType(string t, data_type to, string f, data_type from);

void convertIntToBool(expression* expr);    // converts int to bool expressions

int sizeOfType(data_type t);    // returns the size of the data type

string checkType(symbol_type t);    // to check the types

string getInitVal(symbol* sym);     // to get the initial values

/*
    Standard size assigned 
    but these can be changed if the system supports different sizes
*/

#define size_of_void 0
#define size_of_function 0
#define size_of_character 1
#define size_of_integer 4
#define size_of_pointer 8
#define size_of_float 8

#endif